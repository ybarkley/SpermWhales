---
title: "AcOnly GAMs"
author: "Yvonne Barkley"
date: "9/25/2020"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(
  comment = '', fig.width =8, fig.height = 6
)
```

Load libraries
```{r, echo=FALSE}
library(tidyverse)
library(mgcv)
library(corrplot)
library(geoR)
library(tidymv)
library(here)
```

Load universal variables
```{r}
#Values used for file and directory names
survey = 'AllSurveys'
gridsize = 25
loctype = 'AcOnly'
loctype2 = 'Ac'

```


Load data
```{r}
PmScaled <- readRDS(here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_scaled.rda') ))
PmRaw <- readRDS(here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_scaled.rda') ))

CompletePreds <- dplyr::select(PmRaw, sst:d2smt)
# PmScaled <- readRDS(here::here(paste0('output/envData/', gridsize, ' km-', loctype), paste0('CompletePm_', gridsize, 'km_', loctype2, '_scaledNEW.rda')))

#add column for log effort as offset
PmScaled$log.effort	= log(PmScaled$EffArea)

PmRaw$log.effort	= log(PmRaw$EffArea)
PmRaw$d2smt = PmRaw$d2smt/1000 #for plotting purposes

#save if file again if needed
# saveRDS(PmScaled, here::here( paste0('output/envData/complete env data/', 'CompletePm_', gridsize, 'km_', loctype2, '_scaled2.rda') ))  

nrow(dplyr::filter(PmScaled, pa > 0)) #how many presences? was 118, now should be 147

#rename columns for better plots LATER
# colnames(PmScaled)[c(18:29,44)] <- c('SST', 'Chla', 'Temp600m', 'Wave Power', 'Depth', 'Slope', 'Aspect', 'Dist to Land', 'SSH', 'SSHsd', 'EKE', 'Dist to Seamt', 'Log Effort')

```

Check correlation of covariates
```{r echo=FALSE, eval=FALSE}
corrplot.mixed(cor(PmScaled[,18:29]), upper="number", lower="circle")

```

#Plot the data, see what's happening
Did this in DataCleanup
```{r,eval=FALSE}
# par(mfrow = c(1,1))
# with(CompleteTotal, plot(pa~bath_m))
require(Cairo)
require(ggplot2)
source('./code/multiplot.r') 

 
loopVec <- 18:29  #columns from PmScaled to plot
 
# par(mfrow = c(1, 3), mar=c(3,3,1,1), oma=c(0,0,3,1))
 
for (j in loopVec){
   #use original values for plots with PmRaw
   datPlot <- PmScaled[,c(1,j)]  #get dataframe of pa and variable j
   datPlot$bin <- 0
   datPlot$bin <- ifelse(datPlot$pa >0 , 1, 0) #put 1s in color col for plotting later
   datPlot <- select(datPlot, bin, 2, pa)
    #normal plot
   # plot(datPlot[,2], datPlot[,1], xlab = paste('scaled',colnames(datPlot)[2]), ylab = 'whales per cell')
   

   ptplt <-  ggplot(datPlot, aes(datPlot[,2],datPlot[,1], colour=as.factor(datPlot[,1]))) +
       geom_point() +   
     theme(legend.position ="none") +
       xlab(paste(colnames(datPlot)[2], 'scaled' )) +
       ylab('whales per cell')+
       # scale_colour_discrete(name='',labels = c('Whales Absent', 'Whales Present'))+
theme_bw() +
  guides(colour=FALSE)
   
   #histogram
   # hist(datPlot[,2], xlab = paste('scaled',colnames(datPlot)[2]), ylab = 'frequency', main='' )
   
   histplt <- ggplot(datPlot, aes(datPlot[,2], fill=as.factor(datPlot[,1]))) +
     geom_histogram(colour='black', binwidth = 0.5) +
    xlab(paste(colnames(datPlot)[2],'scaled' )) +
    ylab('Frequency') +
     scale_fill_discrete(name = '', labels = c('Whales Absent', 'Whales Present'))+
     theme_bw() +
     theme(legend.position ="top",
           legend.text=element_text(size=16)) 

   
   #do KS test and plot
   datPlot1 <- filter(datPlot, pa >0)
   datPlot0 <- filter(datPlot, pa ==0)

   datKS <- ks.test(datPlot1[,2], datPlot0[, 2])
     cdf0 <- ecdf(datPlot0[,2]); cdf1 <- ecdf(datPlot1[,2]) #make cdfs for the absences and whales for that variable
   #find min and max stats to draw the line between the greatest distance between the distributions
   minMax <- seq(min(datPlot0[,2], datPlot1[,2]), max(datPlot0[,2], datPlot1[,2]), length.out=length(datPlot0[,2])) 
   x0 <- minMax[which( abs(cdf0(minMax) - cdf1(minMax)) == max(abs(cdf0(minMax) - cdf1(minMax))) )] 
   y0 <- cdf0(x0) #sometimes there are 2 points with the same minmax, take the first one 
   y1 <- cdf1(x0)
   
  ksplt <- ggplot(datPlot, aes(x = datPlot[,2], group = datPlot[,1], color = as.factor(datPlot[,1]))) + #
  stat_ecdf(size=1) +
    theme_bw() +
    theme(legend.position ="none", plot.title = element_text(hjust= 0.5)) +
    xlab(paste(colnames(datPlot)[2],'scaled') ) +
    ylab("ECDF") +
    #geom_line(size=1) +
    geom_segment(aes(x = x0[1], y = y0[1], xend = x0[1], yend = y1[1]),
        linetype = "dashed", color = "red") +
    geom_point(aes(x = x0[1] , y= y0[1]), color="red", size=2) +
    geom_point(aes(x = x0[1] , y= y1[1]), color="red", size=2) +
    ggtitle("K-S Test") +
    # theme(legend.title=element_blank()) +
     scale_colour_discrete(name = 'Distribution Type', labels = c('Whales Absent', 'Whales Present'))+
    annotate("text",x=max(datPlot[,2])-2,y=min(datPlot[,1])+0.1, hjust=.2,label=paste('D=',round(datKS[1]$statistic,2))) +
    annotate("text",x=max(datPlot[,2])-2,y=min(datPlot[,1])+0.05, hjust=.2,label=paste('p=',round(datKS$p.value,3)))

Cairo(here::here('figures', paste0('DataPlotsScaled_', gridsize, 'km_', loctype,'_', colnames(datPlot)[2], '.png')), width=14,height=6,
    units='in', dpi=300, bg='white')
  multiplot(ptplt, histplt, ksplt, cols=3)
 dev.off()
  
   # ggsave(paste('DataPlots_',colnames(datPlot)[2],'.png'))
  
  }

```
More plots
```{r eval=FALSE, echo=FALSE}

 histT600 <- ggplot(PmRaw, aes(temp600, fill=as.factor(pa))) +
     geom_histogram(colour='black', binwidth = 0.5) +
    xlab(paste(colnames(datPlot)[2],'scaled' )) +
    ylab('Frequency') +
     scale_fill_discrete(name = 'Number of Whale Groups') + # labels = c('Whales Absent', 'Whales Present'))+
     theme_bw() +
     theme(legend.position ="top",
           legend.text=element_text(size=16)) 


```


#split the data into train and test sets
```{r eval=FALSE, echo=FALSE}
# split datasets into 70% train and 30% test (i.e., independent)
splitdf <- function(dataframe, seed=NUL) {
    if (!is.null(seed)) set.seed(seed)
    index <- 1:nrow(dataframe)
    trainindex <- sample(index, trunc(length(index)*0.7))
    trainset <- dataframe[trainindex, ]
    testset <- dataframe[-trainindex, ]
    list(trainset=trainset,testset=testset)
}

trainAcOnly = NULL
testAcOnly = NULL
for (s in c(1641, 1303, 1604, 1705, 1706)){
   
 trSub <- filter(PmScaled, survey == s)

 #subset for presences and split 70/30
 pres1 <- filter(trSub, pa  > 0 )
 listPres  <- splitdf(pres1, 666) #output is list for train and test

 #subset for absences and split 70/30
 abs0  <- filter(trSub, pa == 0 )
 listAbs <- splitdf(abs0, 666)  #output is list for train and test

 #combine train data for presence and absence
 trainAll <- rbind( listPres$trainset, listAbs$trainset )
 
 #combine test data for presence and absence
 testAll  <- rbind( listPres$testset,  listAbs$testset  )
   
trainAcOnly = rbind( trainAcOnly, trainAll )
testAcOnly  = rbind( testAcOnly,  testAll)

}

nrow(filter(trainAcOnly, pa >0))
nrow(filter(testAcOnly, pa >0))

```

#KS Test
For distributions to be significantly different, p-value < 0.05.

This compares the distributions of each env data variable between all absences and the whale positive cells. 
It is also set up to take a sample of the absences (samp_pa0) equal to the nrow of the whale+ cells.
Sent to Jeff P. to take a look.
https://rpubs.com/mharris/KSplot  -  Used this site for plot code.

The second part uses KS test to compare the distributions of the env vars between the cells using the localized whale positions and the cells of the same whales but using the cells associated with their position on the trackline. This will evaluate whether the env data are truly different for whales localized at greater distances from the ship. 
```{r eval=FALSE, echo=FALSE}
require(Cairo)
#PART 1: Using the localized whale and sighting data, compare the distributions of env data between whale+ and whale- cells
#Separate the whale+ and whale- cells
ks_pa0 <- filter(PmScaled, pa ==0)
ks_pa1 <- filter(PmScaled, pa > 0)
#Pull out just the covariates for whales and absences
ks_var0 <- ks_pa0[, 18:29]
ks_var1 <- ks_pa1[, 18:29]

#PART 2: Compare distributions between the localized and trackline points for the same whales
ks_trk <- readRDS(here::here(paste0('output/envData/', gridsize, ' km-trackline/CompletePm_', gridsize, 'km_trk_scaled.rda')))
ks_trk1 <- filter(ks_trk, pa > 0)



Cairo(here::here('figures', paste0('KStests_', gridsize, 'km_', loctype, '_allAbs300b.png')), width=6,height=4,
    units='in', dpi=300, bg='white')

par(mfrow = c(3, 4), mar=c(3,3,2,1), oma=c(0,0,3,1))

for (v in 1:length(ks_var0)){ #for each variable
     
  samp_pa0 <- ks_var0[,v] #take a sample of the variable from the absences df to equal the number of samples of positive whales
  # samp_pa0 <- sample(ks_var0[, v], nrow(ks_pa1)) #take a sample of the variable from the absences df to equal the number of samples of positive whales

  ksSW <- ks.test(samp_pa0, ks_var1[, v])        #do the KS test for the variable
    
  cdf0 <- ecdf(samp_pa0); cdf1 <- ecdf(ks_var1[,1]) #make cdfs for the absences and whales for that variable
   #find min and max stats to draw the line between the greatest distance between the distributions
   minMax <- seq(min(samp_pa0, ks_var1[, v]), max(samp_pa0, ks_var1[, v]), length.out=length(samp_pa0)) 
   x0 <- minMax[which( abs(cdf0(minMax) - cdf1(minMax)) == max(abs(cdf0(minMax) - cdf1(minMax))) )] 
   y0 <- cdf0(x0) #sometimes there are 2 points with the same minmax, take the first one 
   y1 <- cdf1(x0) 
  
 plot(cdf0, verticals=TRUE, do.points=FALSE, col="blue", main = paste(colnames(ks_var1[v]), '(pval=',signif(ksSW$p.value,2 ),')'), ylab = "CDF", xlab = 'scaled variable', cex.main = 0.75, cex.axis = 0.75, cex.lab = 0.8 ) 
 plot(cdf1, verticals=TRUE, do.points=FALSE, col="green", add=TRUE) 
 points(c(x0, x0), c(y0, y1), pch=16, col="red", cex=0.7) 
 segments(x0, y0, x0, y1, col="red", lty="dotted", cex = 0.6) 
 # text(0, 0.1, paste('pval = ',signif(ksSW$p.value,2 )), cex = 1, lwd=0.8, pos=3)
 mtext('KS Tests', side=3, line=1, outer=TRUE, cex=1, font=1)

}

dev.off()
   




```


#GAM
Thin-plate regression splines are the default basis for smoothers using 10 knots resulting in 10 raw parameters per 1D smoother. 
Environmental data predictors were set as smoothers using 3 degrees of freedom (k=3) per recommendations from the literature to reduce overfitting in similar types of cetaceans distribution models.The log of effort was included as an offset to account for the variation in effort per cell.
The data are treated as count data, number of sperm whale encounters per cell, and we used the Tweedie distribution since it has been shown to work well when fewer positive responses exist within the data.


##25km - Tweedie

No knot contrain
```{r, eval=FALSE, echo=FALSE}
# colnames(PmScaled)

#No 2D smoother for longitude and latitude
tw25 <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort), data = PmScaled, family = tw)
summary(tw25)
par(mfrow = c(1,2))
plot(tw25)
gam.check(tw25)

tw25LL <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + s(Longitude, Latitude) + offset(log.effort), data = PmScaled, family = tw)
summary(tw25LL)
par(mfrow = c(1,2))
plot(tw25LL)
gam.check(tw25)

# tw25_p <- predict_gam(tw25)

```

Knots contrained to k=3
Automatic term selection is uses an additional penalty term when determining the smoothness of the function.
  We excluded all non-significant variables (alpha=0.05) and refit the models until all variables were significant.
REML is restricted maximum likelihood used to optimize the parameter estimates.
```{r,eval=FALSE, echo=FALSE}}

tw25k3sel <- gam(pa ~ s(bath_m, k=3)+s(dist, k=3) + s(slope, k=3) + offset(log.effort), data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")
summary(tw25k3sel)

par(mar=c(4,4,3,3),mfrow = c(2,2))
plot(tw25k3selBraw, pages = 1, residuals = TRUE, pch = 20, cex = 0.25,
scheme = 1, shade = T, shade.col = 'darkseagreen2', all.terms = TRUE)


# + s(sst, k=3) + s(chla, k=3) + s(temp600) + s(slope, k=3) + s(aspect, k=3) + s(ssh, k=3) + s(sshsd, k=3) + s(eke, k=3) + s(wavepow, k=3) + s(d2smt, k=3) + s(dist, k=3) + 
```


```{r, eval=FALSE, echo=FALSE}
#testing without log.effort offset
tw25k3sel2 <- gam(pa ~ s(bath_m, k=3) + s(sst, k=3) + s(chla, k=3) + s(temp600) + s(slope, k=3) + s(aspect, k=3) + s(ssh, k=3) + s(sshsd, k=3) + s(eke, k=3) + s(wavepow, k=3) + s(d2smt, k=3) +s(dist, k=3), data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")

#Used raw data for plotting purposes like a kook
tw25k3selraw <- gam(pa ~ s(bath_m, k=3) + s(sst, k=3) + s(chla, k=3) + s(temp600) + s(slope, k=3) + s(aspect, k=3) + s(ssh, k=3) + s(sshsd, k=3) + s(eke, k=3) + s(wavepow, k=3) + s(d2smt, k=3) +s(dist, k=3) + offset(log.effort), data = PmRaw, family = tw, link = 'log', select = TRUE, method = "REML")
summary(tw25k3sel)
summary(tw25k3selraw) #just checking that these are the same so I can plot raw values

gam.check(tw25k3sel)

par(mar=c(4,4,3,3))
plot(tw25k3selraw, pages = 3, residuals = TRUE, pch = 20, cex = 0.25,
scheme = 1, shade = T, shade.col = 'deepskyblue', ylim = c(-20, 10))
```

Taking previous model with k=3, auto term selection and changing some variables from smoothers to linear parameters
```{r, eval=FALSE, echo=FALSE}

tw25k3selB <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(eke, k=3) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort), data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")
tw25k3selBraw <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(eke, k=3) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort), data = PmRaw, family = tw, link = 'log', select = TRUE, method = "REML")

summary(tw25k3selB)
gam.check(tw25k3selB)
par(mar=c(4,4,3,3),mfrow = c(2,2))
plot(tw25k3selBraw, pages = 1, residuals = TRUE, pch = 20, cex = 0.25,
scheme = 1, shade = T, shade.col = 'darkseagreen2', all.terms = TRUE)

#eke not significant, remove from model
tw25k3selC <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort), data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")
tw25k3selCraw <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort), data = PmRaw, family = tw, link = 'log', select = TRUE, method = "REML")
summary(tw25k3selC)
gam.check(tw25k3selC)
par(mar=c(4,4,3,3),mfrow = c(2,2))
plot(tw25k3selCraw, pages = 1, residuals = TRUE, pch = 20, cex = 0.25,
scheme = 1, shade = T, shade.col = 'salmon1', all.terms = TRUE)

#increase knots for wave power
tw25k3selD <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=4) + s(d2smt, k=3) + dist + offset(log.effort), data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")
summary(tw25k3selD)
gam.check(tw25k3selD)
tw25k3selDraw <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=4) + s(d2smt, k=3) + dist + offset(log.effort), data = PmRaw, family = tw, link = 'log', select = TRUE, method = "REML")
plot(tw25k3selDraw, pages = 1, residuals = TRUE, pch = 20, cex = 0.25,
scheme = 1, shade = T, shade.col = 'royalblue1', all.terms = TRUE)

#plot with all signif variables and add 2D smoother
tw25k3selE <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort) + s(Longitude, Latitude), 
        data = PmScaled, family = tw, link = 'log', select = TRUE, method = "REML")

tw25k3selEraw <- gam(pa ~ bath_m + sst + chla + s(temp600) + s(wavepow, k=3) + s(d2smt, k=3) + dist + offset(log.effort) + s(Longitude, Latitude),    
        data = PmRaw, family = tw, link = 'log', select = TRUE, method = "REML")
summary(tw25k3selE)
gam.check(tw25k3selE)

par(mar=c(4,4,3,3), mfrow=c(3,3))
plot(tw25k3selEraw, residuals = F, pch = 20, cex = 0.25,
 shade = TRUE, shade.col = 'salmon1', all.terms=TRUE, scale=0)

# hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)

points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20)
points()
par(mar=c(4,4,3,3), mfrow=c(1,1))

```

What happens when a 2D lat/lon smoother is fit only?
```{r, eval=FALSE, echo=FALSE}
# require(SDraw) #doesn't work
tw25kLL <- gam(pa ~ s(Longitude, Latitude), data = PmScaled, family = tw, link='log', select = TRUE, method = "REML")
summary(tw25kLL)
gam.check(tw25kLL)

saveRDS(hawaiiMap, here::here(paste0('data/hawaiiMap..rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)

whales <- filter(PmScaled, pa >0) #get points for whales to plot

plot(tw25kLL, select = 1, scheme = 2, lwd = 2)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex=0.5, col = 'black')
points(whales$Longitude, whales$Latitude, pch = 1, col='slateblue', lwd=2, cex=0.75)



us<-readOGR(here::here( paste0("data/tl_2016_us_state.shp")))
hawaii<-subset(us,NAME=="Hawaii")
hawaiiMap<-fortify(hawaii)
```


```{r, eval=FALSE, echo=FALSE}

#Includes 2D smoother for longitude and latitude
tw25b <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort) + s(Longitude, Latitude), data = PmScaled, family = tw)

#Includes 2D smoother & year (survey)
tw25c <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort) + s(Longitude, Latitude) + survey, data = PmScaled, family = tw)

```






## Binomial for 10 km and 5 km
```{r, eval=FALSE}
# colnames(PmScaled)

#No 2D smoother for longitude and latitude
gamnb_full <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort), data = PmScaled, family = binomial, link = 'logit')

gamBINOM <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort), data = PmScaled, family = binomial, link = 'logit')

gamnb_full.sel <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort), data = PmScaled, family = nb, select = TRUE)

#Includes 2D smoother for longitude and latitude
ptm=proc.time()
gamnb_fullb <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort) + s(Longitude, Latitude), data = PmScaled, family = nb)
(min_wavepow=proc.time()-ptm) 
min_wavepow[3]/60

#Includes 2D smoother & year (survey)
gamnb_fullc <- gam(pa ~ s(bath_m) + s(sst) + s(chla) + s(temp600) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort) + s(Longitude, Latitude) + survey, data = PmScaled, family = nb)

gamnb_fullc <- gam(pa ~ s(bath_m, bs='cr', k=3) + s(sst, bs='cr', k=3) + s(chla, bs='cr', k=3) + s(temp600, bs='cr', k=3) + s(slope) + s(aspect) + s(ssh) + s(sshsd) + s(eke) + s(wavepow) + s(d2smt) +s(dist) + offset(log.effort) + s(Longitude, Latitude) + survey, data = PmScaled, family = nb)

```

##10km - summary
```{r, eval=FALSE, echo=FALSE}
#No 2D smoother
summary(gamnb_full)

par(mfrow=c(2,2))
plot(gamnb_full, pages=2)

gam.check(gamnb_full)

#Includes 2D smoother
summary(gamnb_fullb)

par(mfrow=c(2,2))
plot(gamnb_fullb, pages=3)

gam.check(gamnb_fullb)

#Includes 2D smoother and year
summary(gamnb_fullc)
plot(gamnb_fullc, pages =3)
par(mfrow=c(2,2))
gam.check(gamnb_fullc)

# plot(allEffects(model, partial.residuals = TRUE))
```

###Variogram 
*How similar are the residuals relative to their distance from each other in space?
  This tests for autocorrelation. If nearby residuals are similar due to unmeasured env effects, for example, the variogram will show a pattern where there are lower values at lower distances and then an increase at farther distances. 
```{r, eval=FALSE, echo=FALSE}
vnb_full <- variog(coords = PmScaled[,c('Latitude','Longitude')],	data= residuals(gamnb_full, type = 'pearson'))
plot(vnb_full)

vnb_fullb <- variog(coords = PmScaled[,c('Latitude','Longitude')],	data= residuals(gamnb_fullb, type = 'pearson'))
plot(vnb_fullb)

vnb_fullc <- variog(coords = PmScaled[,c('Latitude','Longitude')],	data= residuals(gamnb_fullc, type = 'pearson'))
plot(vnb_fullc)

```

###Examine Spatial Autocorrelation
```{r}

#let's try looking at the spatial auto in model residuals








```


```{r, echo=FALSE, eval=FALSE}

v1 <- variog(coords = PmScaled[,c('Latitude','Longitude')],	data= residuals(gam_fullb,type = 'pearson'))

plot(v1)

v2 <- variog(coords = PmScaled[,c('Latitude','Longitude')],	data= residuals(gam_fullc,type = 'pearson'))

plot(v2)

```

##First attempts
```{r, echo=FALSE,eval=FALSE}
mod_gam1b <- gam(pa ~ s(bath_m, bs = 'cr'), data = PmScaled, family = negbin(3))
summary(mod_gam1b)
plot(mod_gam1b)

#with smoother for spatial autocorrelation using centroid locations
mod_gam2 <- gam(pa ~ s(bath_m)+s(Longitude, Latitude), data = PmScaled, family = negbin(3))
summary(mod_gam2)
plot(mod_gam2)

mod_gam3 <- gam(pa ~ s(bath_m)+s(Longitude, Latitude), data = PmScaled, family = negbin(3))
summary(mod_gam3)
plot(mod_gam3, residuals)
gam.check(mod_gam3)
```


## Plotting 
```{r, echo=FALSE,eval=FALSE}
#from http://environmentalcomputing.net/intro-to-gams/
ggplot(Sample_data, aes(x, y)) + geom_point() + geom_smooth(method = "gam", formula = y ~s(x))


plot.gam()
```

