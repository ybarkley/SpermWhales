---
title: "Summary of SDMs for Foraging and Non-Foraging Groups"
author: "Yvonne Barkley"
date: "10/18/2020"
output:
 pdf_document:
    
    latex_engine: xelatex
    extra_dependencies: ["flafter"]
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = '', fig.width =8, fig.height = 6, message=FALSE, tidy.opts=list(width.cutoff=60))
```

### This document summarizes the results of comparing sperm whale distribution models for:
  * FORAGING and NON-FORAGING WHALE groups.

Both models were built using the combined data set, which included sightings with concurrent acoutic encounters and acoustic encounters without an associated sighting.


 * **Foraging Groups**    
     * Groups with regular clicks or creaks identified with an inter-click interval between 0.5 - 1 s 
     * n = 104 foraging encounters
 
 * **Non-Foraging Groups**    
     * Groups without regular clicks or creaks. These models included groups with codas or slow clicks present.
     * n = 76 non-foraging encounters

$~$

### Environmental Variables  

All models incorporated biologically relevant environmental predictors that represented bathymetric features or oceanographic processes that act as proxies for mechanisms driving sperm whale prey distribution. The correlation between environmental variables was tested prior to model fitting. All environmental variables included in the models (listed in the table below) resulted in correlation coefficients < |0.6|.
Chlorophyll, EKE and wave power were log-transformed to reduce the skew and minimize the leverage of outlying data points during model fitting.

The spatial plots of the dynamic variables also provide an overview of the gradients within the environmental data.


```{r echo=FALSE}
## image ####
require(here)
require(knitr)
include_graphics(here('figures/EnvDataTable3.png'))
```
```{r echo=FALSE, fig.cap='Spatial plots of all dynamic environmental variables tested in the models.', fig.width=4, fig.height=6}
## image ####
require(here)
require(knitr)
include_graphics(here('figures/SwMap_AllDyn2.png'))
```


$~$


### Model Construction
A 25-km spatial resolution was used to compute the unit of analysis (25 x 25 grid cell) for the number of sperm whale groups per unit. Preliminary models also tested a 10-km spatial resolution, but increasing the spatial resolution did not result in any significant changes to the strength of correlations between encounter rate and environmental variables. 

Model data sets were divided into train and test data sets using a 70/30 split. GAMs were fitted using a negative binomial with a log-link function as this is an appropriate distribution for over-dispersed data sets consisting of relatively sparse count data with large numbers of zeros. All smoothers were fit using thin-plate regression splines (the default basis). Each simple smoother was limited to 3 degrees of freedom (k=3) to reduce overfitting parameters per recommendations from other studies building similar types of cetaceans distribution models. A spatial smoother ( s(Lon, Lat, k=10) ) was also included in all models to account for spatial autocorrelation within the data. The number of knots was increased to 10 based on model diagnostics to account for the complexity of the spatial smoother and minimize overfitting the data. The log of the effort was also included as an offset to account for the variation in search effort per grid cell. 

* Model variable selection was performed in two ways to select variables using:
  * Forward selection starting with a spatial smoother since there is spatial structure within the data set. Each environmental variables was added to the spatial smoother model and assessed using AIC, explained deviance, and whether it was statistically significant (p < 0.05).
  * Backward selection starting with a full model using all variables. Non-significant variables were removed and the model was refitted until all remaining variables were significant.
  * Selecting the final variables included comparing models with AIC during both selection procedures. Then, the best models were compared to select the most parsimoniuous set of variables.


```{r, echo=F, eval=FALSE, message=FALSE}
library(tidyverse)
library(mgcv)
library(corrplot)
library(geoR)
library(tidymv)
library(here)
library(lubridate)
```

```{r echo=FALSE}
#Values for COMBINED MODELS
survey = 'AllSurveys'
gridsize = 25
loctype = 'Combined'
loctype2 = 'Comb'
#data has logged vars and temporal variables
## SAVED from line 251 in 10_PmSDM_AcousticCombined.rmd
PmCombo <- readRDS(here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_EDIT.rda') ))
# PmCombo2 <- readRDS(here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_scaled.rda') ))


```

# YB Revisits 
2/7/22 Hello old friend
A few encounters need to have the click codes changed as a result of closer inspection during ACCURATE click analysis. The changes will be made in PmCombo prior to splitting the train and test data and any foraging/non-foraging analysis.
Changes are determined by the yellow-highlighted 'click_code' cells in the ACCURATE Project Sheet.
### 2022: Redo Click Codes
```{r}
PmCombo$click_code[PmCombo$ID == "1303_42_21"] <- "cdckrs"  #(was ckrs, added coda)
PmCombo$click_code[PmCombo$ID == "1604_30_999"] <- "rs"     #(was s)
PmCombo$click_code[PmCombo$ID == "1604_67_999"] <- "rs"     #(was s)
PmCombo$click_code[PmCombo$ID == "1705_251_999"] <- "rs"    #(was s)
PmCombo$click_code[PmCombo$ID == "1706_2_999"] <- "rs"      #(was r)
PmCombo$click_code[PmCombo$ID == "1706_41_999"] <- "rs"     #(was s)
# PmCombo$click_code[PmCombo$ID == "1706_135_999"] <- "ckrs" #not included as separate encounter, was combined with 1706A49 in same cell, which is also ckrs
PmCombo$click_code[PmCombo$ID == "1303_71_999"] <- "rs"     #(was s)


```


No need to rerun
```{r eval=FALSE, echo=FALSE}
##### COMBO: log transform, temporal variables, click code redo #####


PmCombo$log.effort	= log(PmCombo$EffArea)
PmCombo$log.chla <- log(PmCombo$chla.r)
PmCombo$log.eke <- log(PmCombo$eke.r)
PmCombo$log.wp <- log(PmCombo$wavepower.r)

#From Jeff, Oct 14, 2020
#add year and quarterly time variables
#year
PmCombo$year <- 2010
PmCombo$year[PmCombo$survey==1303] <- 2013 
PmCombo$year[PmCombo$survey==1604] <- 2016
PmCombo$year[PmCombo$survey==1705] <- 2017
PmCombo$year[PmCombo$survey==1706] <- 2017
PmCombo2 <- select(PmCombo, last_col(), everything())

#quarter: test on PmCombo2, then add to PmCombo - NO NEED
dateSplit = data.frame(1, time=as.character(as.Date(PmCombo$UTC)))  #some data finagling
dateSplit2 = separate(dateSplit, "time",  c("year", "month", "day")) #splits date into year, month, day
PmCombo$month = as.numeric(dateSplit2$month) #added to PmCombo2 to test, but doing it with PmCombo here
PmCombo$qtr = 1
PmCombo$qtr[PmCombo$month >= 4 & PmCombo$month <=6] <- 2 
PmCombo$qtr[PmCombo$month >= 7 & PmCombo$month <=9] <- 3
PmCombo$qtr[PmCombo$month >= 10 & PmCombo$month <=12] <- 4
# PmCombo <- select(PmCombo, last_col(), everything())
# PmCombo$qtr <- PmCombo2$qtr

# saveRDS(PmCombo, here::here(  paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_scaled.rda') ))
```


No need to rerun
```{r echo=FALSE, eval=FALSE}
### MUST DO!!!!! CLICK CODE REDO ####
# need to validate the click code and make sure the cells with > 1 group have all clicks accounted for.
# did this somewhat manually by looking at each 'manyGrps' subset separately to combine click codes into one row to represent the cell. Didn't care about the individual data for each detection itself at this point. but that info is still available.

 # 1) find which rows have > 1 group in a cell 
manyGrps1641 =  PmCombo[ which(PmCombo$pa  > 1 & PmCombo$survey == 1641), ]
manyGrps1303 =  PmCombo[ which(PmCombo$pa  > 1 & PmCombo$survey == 1303), ]
manyGrps1604 =  PmCombo[ which(PmCombo$pa  > 1 & PmCombo$survey == 1604), ]
manyGrps1705 =  PmCombo[ which(PmCombo$pa  > 1 & PmCombo$survey == 1705), ]
manyGrps1706 =  PmCombo[ which(PmCombo$pa  > 1 & PmCombo$survey == 1706), ]

 # 2) add in the missing click type to the click code VERY CAREFULLY: no need for 1303 in this step
manyGrps1641[1,54] <- 'cdcks'
manyGrps1641[3,54] <- 'ckcd'

manyGrps1604[1,54] <- 'cdr'

manyGrps1705[2,54] <- 'cdrs'
manyGrps1705[2,54] <- 'cdrs'

manyGrps1706[1,54] <- 'rs'
manyGrps1706[3,54] <- 'ckrs'


 # 3) keep the rows with all encompassing click code
manyGrps1641ed <- manyGrps1641[c(1,3,5,7), ]
manyGrps1303ed <- manyGrps1303[c(1,4,5,8), ]
manyGrps1604ed <- manyGrps1604[1, ]
manyGrps1705ed <- manyGrps1705[2, ]
manyGrps1706ed <- manyGrps1706[c(1,3,5,6), ]


# gotta remove these rows from PmCombo...
PmCombosubby <- filter(PmCombo, pa==0 | pa == 1) #sweet, works

PmCombo <- rbind(PmCombosubby, manyGrps1641ed, manyGrps1303ed, manyGrps1604ed ,manyGrps1705ed, manyGrps1706ed)

#save edits
PmComboSAVE <- rbind(PmCombosubby, manyGrps1641ed, manyGrps1303ed, manyGrps1604ed ,manyGrps1705ed, manyGrps1706ed)
saveRDS(PmComboSAVE, here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_EDIT.rda') ))

PmComboSAVE <- readRDS(here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_EDIT.rda') ))
#edit for Zack, just raw data
PmComboSAVE <- PmComboSAVE[, c(1,2,30,31,32,34,38,39)]
saveRDS(PmComboSAVE, here::here( paste0('output/models/', loctype, '/data/', 'CompletePm_', gridsize, 'km_', loctype2, '_forZack.rda') ))
```
### Saving new train/test data in 2022 Revisions folders
"C:/Users/yvers/Documents/CHP 3/SpermWhales/output/models/Combined/data/2022_revisions/Train_25km_Comb_revise.rda"
```{r eval=FALSE, echo=FALSE}
## COMBO: REDO TRAIN TEST for COMBO MODELS ####
require(dplyr)
splitdf <- function(dataframe, seed=NULL) {
    if (!is.null(seed)) set.seed(seed)
    index <- 1:nrow(dataframe)
    trainindex <- sample(index, trunc(length(index)*0.7))
    trainset <- dataframe[trainindex, ]
    testset <- dataframe[-trainindex, ]
    list(trainset=trainset,testset=testset)
}

trainComb = NULL
testComb = NULL
seed = 2

for (s in c(1641, 1303, 1604, 1705, 1706)){
   
 trSub <- filter(PmCombo, survey == s)

 #subset for presences and split 70/30
 pres1 <- filter(trSub, pa > 0 )# & loc == 1) #include all presence data/acoustic encounters
 listPres  <- splitdf(pres1, seed) #output is list for train and test

 #subset for absences and split 70/30
 abs0  <- filter(trSub, pa == 0 )
 listAbs <- splitdf(abs0, seed)  #output is list for train and test

 #combine train data for presence and absence
 trainAll <- rbind( listPres$trainset, listAbs$trainset )
 
 #combine test data for presence and absence
 testAll  <- rbind( listPres$testset,  listAbs$testset  )
   
trainComb = rbind( trainComb, trainAll )
testComb  = rbind( testComb,  testAll )

# trainAcOnly$log.effort <- log(trainAcOnly$EffArea)
# testAcOnly$log.effort <- log(testAcOnly$EffArea)
}
saveRDS(trainComb, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Train_', gridsize, 'km_', loctype2, '_revise.rda')  ))
saveRDS(testComb, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Test_', gridsize, 'km_', loctype2, '_revise.rda')  ))

# nrow(dplyr::filter(trainAcOnly, trainAcOnly$pa >0))
# nrow(dplyr::filter(testAcOnly, testAcOnly$pa >0))
```

```{r echo=FALSE}
## COMBO: TRAINING AND TEST DATA #### 

trainComb <- readRDS(here::here(  paste0('output/models/',loctype, '/data/Train_',   gridsize, 'km_', loctype2, '_revise.rda')  ))
testComb <- readRDS(here::here(  paste0('output/models/',loctype, '/data/Test_',     gridsize, 'km_', loctype2, '_revise.rda')  ))

# trainComb <- readRDS(here::here(  paste0('output/models/',loctype, '/data/Train_',   gridsize, 'km_', loctype2, '_Comb3.rda')  ))
# testComb <- readRDS(here::here(  paste0('output/models/',loctype, '/data/Test_',     gridsize, 'km_', loctype2, '_Comb3.rda')  ))

```




## Foraging and Non-Foraging Group Models

#### Foraging models incorporated a subset of the sperm whale encounters from the Combined Models (sighted with acoustics, and acoustics only) that only included encounters with **regular clicks** and **creaks** to indicate foraging.


```{r eval=FALSE,echo=FALSE}
## Forage and Social Group Data Subset ####
#1. Denote forage or not. 
PmFor1 <- filter(PmCombo, grepl('r|k', click_code))   # the 'k' implies ck for creaks because c also for codas
PmFor0 <- filter(PmCombo, !grepl('r|k', click_code))
PmFor1$forage <- 1  #forage
PmFor0$forage <- 0  #non-forage
PmForage <- dplyr::bind_rows(PmFor1, PmFor0)

nrow(PmFor0)
nrow(PmFor1)

#2. Denote non-foraging
PmPositive <- filter( PmCombo, pa > 0 )
PmAbsent <- filter( PmCombo, pa == 0 )

PmNonFor1 <- filter(PmPositive, !grepl('r|k', click_code))  #subset all encs without r or ck in click_code
PmNonFor0 <- filter(PmPositive, grepl('r|k', click_code))

#designate whether the encounters included codas (1) or not (0)
PmNonFor1$nonfor <- 1
PmNonFor0$nonfor <- 0
PmAbsent$nonfor <- 0

PmNonFor <- rbind(PmNonFor1,PmNonFor0, PmAbsent)


PmNonFor2 <- PmNonFor[, c(1,2,4,54,62)]

nrow(PmNonFor1)  # represent all non-foraging 
nrow(PmNonFor0)  # represent all foraging encounters, which are now 0
```




Using a 70 / 30 split for training and test data sets
```{r eval=FALSE, echo=FALSE}

# FORAGE: REDO Train Test ####

require(dplyr)
splitdf <- function(dataframe, seed=NULL) {
    if (!is.null(seed)) set.seed(seed)
    index <- 1:nrow(dataframe)
    trainindex <- sample(index, trunc(length(index)*0.7))
    trainset <- dataframe[trainindex, ]
    testset <- dataframe[-trainindex, ]
    list(trainset=trainset,testset=testset)
}

trainForg = NULL
testForg = NULL
# preschk = NULL
seed = 123

for (s in c(1641, 1303, 1604, 1705, 1706)){
   
 trSub <- filter(PmForage, survey == s)

 #subset for presences and split 70/30
 pres1 <- filter(trSub, pa > 0 & forage == 1)# & loc == 1) #include all presence data/acoustic encounters
 listPres  <- splitdf(pres1, seed) #output is list for train and test
# preschk = rbind(preschk, pres1)
 #subset for absences and split 70/30
 abs0  <- filter(trSub, pa == 0 )
 listAbs <- splitdf(abs0, seed)  #output is list for train and test

 #combine train data for presence and absence
 trainAll <- rbind( listPres$trainset, listAbs$trainset )
 
 #combine test data for presence and absence
 testAll  <- rbind( listPres$testset,  listAbs$testset  )
   
trainForg = rbind( trainForg, trainAll )
testForg  = rbind( testForg,  testAll )

# trainAcOnly$log.effort <- log(trainAcOnly$EffArea)
# testAcOnly$log.effort <- log(testAcOnly$EffArea)
}

#keep in mind these include the log variables too
saveRDS(trainForg, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Train_', gridsize, 'km_', loctype2, '_HuntRevise2.rda')  ))
saveRDS(testForg, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Test_', gridsize, 'km_', loctype2, '_HuntRevise2.rda')  ))

# nrow(dplyr::filter(trainAcOnly, trainAcOnly$pa >0))
# nrow(dplyr::filter(testAcOnly, testAcOnly$pa >0))
```

```{r eval=FALSE, echo=FALSE}
# Non-Foraging: REDO Train Test ####

trainNonFor = NULL
testNonFor = NULL
# preschk = NULL
seed = 4

for (s in c(1641, 1303, 1604, 1705, 1706)){
   
 trSub <- filter(PmNonFor, survey == s)

 #subset for presences and split 70/30
 pres1 <- filter(trSub, pa > 0 & nonfor == 1)# & loc == 1) #include all presence data/acoustic encounters
 listPres  <- splitdf(pres1, seed) #output is list for train and test
# preschk = rbind(preschk, pres1)
 #subset for absences and split 70/30
 abs0  <- filter(trSub, pa == 0 )
 listAbs <- splitdf(abs0, seed)  #output is list for train and test

 #combine train data for presence and absence
 trainAll <- rbind( listPres$trainset, listAbs$trainset )
 
 #combine test data for presence and absence
 testAll  <- rbind( listPres$testset,  listAbs$testset  )
   
trainNonFor = rbind( trainNonFor, trainAll )
testNonFor  = rbind( testNonFor,  testAll )

# trainAcOnly$log.effort <- log(trainAcOnly$EffArea)
# testAcOnly$log.effort <- log(testAcOnly$EffArea)
}
saveRDS(trainNonFor, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Train_', gridsize, 'km_', loctype2, '_NonForRevise2.rda')  ))
saveRDS(testNonFor, here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Test_', gridsize, 'km_', loctype2, '_NonForRevise2.rda')  ))

# nrow(dplyr::filter(trainAcOnly, trainAcOnly$pa >0))
# nrow(dplyr::filter(testAcOnly, testAcOnly$pa >0))
```
### Load Train and Test data
```{r echo=FALSE}
## FORAGE/NON-FORAGE: LOAD TRAIN and TEST ####
# trainHunt <- trainForg
# testHunt <- testForg

#seed 1
trainHunt <- readRDS(here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Train_',   gridsize, 'km_', loctype2, '_HuntRevise2.rda')  ))
testHunt <- readRDS(here::here(  paste0('output/models/',loctype, '/data/2022_revisions/Test_',     gridsize, 'km_', loctype2, '_HuntRevise2.rda')  ))

colnames(trainHunt)[30] <- 'SST'
colnames(trainHunt)[57] <- 'log.Chla'
colnames(trainHunt)[32] <- 'Temp584m'
colnames(trainHunt)[38] <- 'SSH'
colnames(trainHunt)[39] <- 'SSHsd'
colnames(testHunt)[30] <- 'SST'
colnames(testHunt)[57] <- 'log.Chla'
colnames(testHunt)[32] <- 'Temp584m'
colnames(testHunt)[38] <- 'SSH'
colnames(testHunt)[39] <- 'SSHsd'
#Removing 2 chla outliers, see notes in Data Analysis checklist, Oct 8, 2020. Doh, kept them in...IDK
# trainHunt <- filter(trainHunt, log.chla < 5) 

#seed 1

trainNonFor <- readRDS(here::here(  paste0('code/REVISIONS/train_testdata/Train_',   gridsize, 'km_', loctype2, '_NonForRevise.rda')  ))
testNonFor <- readRDS(here::here(  paste0('code/REVISIONS/train_testdata/Test_',     gridsize, 'km_', loctype2, '_NonForRevise.rda')  ))

colnames(trainNonFor)[30] <- 'SST'
colnames(trainNonFor)[34] <- 'Depth'
colnames(trainNonFor)[57] <- 'log.Chla'
colnames(trainNonFor)[32] <- 'Temp584m'
colnames(trainNonFor)[38] <- 'SSH'
colnames(trainNonFor)[39] <- 'SSHsd'

colnames(testNonFor)[30] <- 'SST'
colnames(testNonFor)[34] <- 'Depth'
colnames(testNonFor)[57] <- 'log.Chla'
colnames(testNonFor)[32] <- 'Temp584m'
colnames(testNonFor)[38] <- 'SSH'
colnames(testNonFor)[39] <- 'SSHsd'


###TOTALS for Whale Encounters ####
PmForage_total <- subset(PmForage, pa >0 & forage ==1)
PmForage_totalb <- select(PmForage_total, pa, ID, forage, loc)
sum(PmForage_total$pa) # since pa can be > 1
sum(subset(PmForage_totalb, pa >0 & forage ==1 & loc==1)$pa) #localized forage
sum(subset(PmForage_totalb, pa >0 & forage ==1 & loc==0)$pa) #trackline and sighted forage



PmNonFor_total <- subset(PmNonFor, pa >0 & nonfor ==1)
sum(PmNonFor_total$pa)
PmNonFor_totalb <- select(PmNonFor_total, pa, ID, nonfor, loc)

```


#### 1) Foraging Model  

  * gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3)
  * The spatial smoother accounts for the spatial variation not explained by the other predictors in the model. There are obviously some other factors at play that are responsible for the distribution patterns of the foraging whales, but the spatial smoother at least helps to explain the extra variation. A model with only the spatial smoother resulted in an explained deviance of ~12%, but had a higher AIC value relative to the best model (689.7 vs 677.4, respectively).
  * The effect of the Temp at 584m is in the form of a 'U distribution' with a minimum at ~6.8°C. Higher encounter rates were predicted at the minimum and maximum temperatures at 584 m, which are associated with more whale encounters in the cooler region north of the MHI and warmer temperatures north of the NWHI region. The depth of these temperatures reflect the potential temperatures of sperm whale prey habitat. Whether the temperatures directly affect the prey distribution is unclear, but this is one of the more effective variables for explaining the occurrence of sperm whales compared to the other variables.
  * Log-transformed Chl-a was also an important variable despite the counterintuitive negative relationship with encounter rate. There are 2 outliers of higher Chl-a concentrations. Models were tested excluding these outliers and Chl-a remained statistically significant with the negative relationship. 
  * SSHsd resulted in a similar U-distribution as Temp at 584m. SSHsd predicted higher encounter rates at the minimum and maximum SSHsd values (~0 and 0.025 m), with the lowest encounter rates occurring within the middle of the range at ~0.012 m. The lower SSHsd corresponds with the high encounter rate in the MHI region. The higher SSHsd corresponds with the high encounter rate in the NWHI region north and west of Laysan Atoll. This may indicate more mesoscale eddy activity in this area, which is somewhat validated by the spatial plot showing slightly more values of increased eddy kinetic energy in that region. The reasons or processes for higher number of foraging whales in the MHI are less obvious.
    
    
### OLD MODELS ###
```{r echo=FALSE, eval=FALSE}
## FORAGE MODEL ####
# trainHuntb <- dplyr::filter(trainHunt, chla.r < 0.3 ) #even removing outliers, chla still signif

## START HERE WITH 2D SMOOTH
# modForage2Donly <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort) + s(year, k=3) + qtr2 , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# summary(modForage) 

modForage       <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + + s(year, k=3) + qtr + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage) 

modForage2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3) + s(SST, k=3) +offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML") #remove qtr and that makes sst non-sig
summary(modForage2) 

modForage3 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(SSHsd, k=3) +s(log.Chla, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage3) 

modForage4 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(SSHsd, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage4) 

############ TW #######

modForageTW <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort) + s(year, k=3) + qtr , data = trainHunt, family = tw, link = 'log', select = TRUE, method = "REML")
summary(modForageTW) 

modForageTW2 <- gam(pa ~  s(Longitude, Latitude, k=10)  + s(Temp584m, k=3) + s(SSHsd, k=3) + s(qtr, k=3) , data = trainHunt, family = tw, link = 'log', select = TRUE, method = "REML")
summary(modForageTW2) 

par(mar=c(4,4,3,2),mfrow = c(2,2))
gam.check(modForage2)
gam.check(modForageTW2)

########################
modForg2D2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSHsd, k=3) + s(qtr, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForg2D2) 

modForg2D3 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(Temp584m, k=3) + s(qtr, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForg2D3)


# Using all Forage data
modForageAll <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort) , data = PmFor, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForageAll) 
modForageAll <- gam(pa ~  s(Longitude, Latitude, k=10) + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSHsd, k=3) + offset(log.effort) , data = PmFor, family = nb, link = 'log', select = TRUE, method = "REML")


```


```{r echo=FALSE}
require(mgcv)
## OLD- FORAGE MODEL BEST ####
modForageBest <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForageBest)

modForageBest2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) +  s(SSHsd, k=3), offset = log.effort, data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# summary(modForageBest2)

modForagePlot <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# summary(modForagePlot)
#?############ other models #######
# modForageBest <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3) + offset(log.effort) + s(qtr, k=3) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# summary(modForageBest)  #SST depends on qtr, so removing both
#?
# 
# 
# modForageBestOLD <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(Temp584m, k=3) + s(qtr, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# summary(modForageBestOLD) #which now has sst as non-sig

 ## log Chla only
# modForageBest2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(log.Chla, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest2)
#  
##  Temp 584 only
# modForageBest3 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest3)

 ## temp584, sshsd only
#  modForageBest4 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(SSHsd, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest4)
# 
 ## sshsd only
#  modForageBest5 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SSHsd, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest5)
# 
# # log chla and sshsd only 
#  modForageBest7 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(log.Chla, k=3) + s(SSHsd, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest7)
# 
#  modForageBest8 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(SSHsd, k=3) + s(Temp584m, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest8) #no chla
#  
# modForageBest9 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(SSHsd, k=3) + s(log.Chla, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest9) #no temp584
#  
## Lon:Lat only
# modForageBest10 <- gam(pa ~  s(Longitude, Latitude, k=10) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest10)

#   # temp584, chl-a only 
# modForageBest11 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modForageBest11)
# 
# AIC(modForageBest,modForageBest2,modForageBest3,modForageBest4,modForageBest5,modForageBest7,modForage, modForage3, modForageBest10,modForageBest11)

## Lon:Lat only
# modJeff1 <- gam(pa ~  s(Longitude, Latitude, k=10) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modJeff1)
#  
#  modJeff2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SSH, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modJeff2)
# 
#   modJeff3 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#  summary(modJeff3)
#  
#    modJeff4 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SSHsd, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#   summary(modJeff4)
#   
#  modJeff5 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#   summary(modJeff5)
#  modJeff6 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(log.Chla, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#   summary(modJeff6)
# 
#  modJeff7 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(log.eke, k=3) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
#   summary(modJeff7)
#   
#   AIC(modJeff1,modJeff2, modJeff3, modJeff4, modJeff5, modJeff6, modJeff7 )
```

##REVISED MODELS ~~~~~~~
Tried included quarter as both a smoother and a factor -> results were the same.
```{r}
## INCLUDING QTR
modForage       <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + + s(year, k=3) + s(qtr, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage) 

modForage2 <- gam(pa ~  s(Longitude, Latitude, k=10)  + s(SST, k=3) +  s(Temp584m, k=3) + qtr + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML") #remove qtr and that makes sst non-sig
summary(modForage2)

####NO time covariates ####
# due to limited sample years and small sample size to determine population trends (Becker 2021 TM)
modForage_B       <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage_B) 

modForage_B2       <- gam(pa ~  s(Longitude, Latitude, k=10) + s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSHsd, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage_B2) 

### BEST FORAGING MODEL w/ 2D Smoother ####
modForageBest <- modForage_B2
saveRDS(modForageBest,  here::here( paste0('code/REVISIONS/BEST_ForagingModel.rda') ))

# The same variables are selected with the 2D smoother, but less explained deviance, 10.9% vs 18.5%
modForage_C       <- gam(pa ~  s(depth.r, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage_C)

modForage_C2       <- gam(pa ~ s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSHsd, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modForage_C2) 

```
### Foraging Effects Plots
```{r echo=FALSE, fig.cap = "Foraging Model: Partial effects plots for the spatial contour, Temperature at 584 m, log.Chla, and SSHsd." , fig.width=8, fig.height=9}
 
png(file = "C:/Users/yvers/OneDrive/PHD/Chapter 3-Sperm SDM/writing/REVISIONS/Foraging_EffectsPlot_b.png", width = 10, height = 3, res = 300, units = "in") # 8x6"
par(mar=c(4,5,1,1),mfrow = c(1,4))

plot(modForageBest, select=2, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab=expression("SST (°C)"), seWithMean = TRUE, ylim = c(-8,2),cex.axis = 1.2, cex.lab = 1.5 )
plot(modForageBest, select=4, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='Temp at 584 m (°C)' , seWithMean = TRUE, ylim = c(-2,2),cex.axis = 1.2, cex.lab = 1.5)#, shift = coef(modForageBest)[1],	trans	= function(x)	exp(x))

plot(modForageBest, select=5, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='SSHsd (m)',seWithMean = TRUE, ylim = c(-2,2),cex.axis = 1.2, cex.lab = 1.5 )

plot(modForageBest, select=3, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab=expression("log(Chl-a) (mg/m"^3*")"), seWithMean = TRUE, ylim = c(-8,2),cex.axis = 1.2, cex.lab = 1.5 )

dev.off()
# mtext(paste0("Foraging Whales"), side=3, line=1, outer=TRUE, cex=1, font=1)

```

### Foraging 2D plot
```{r eval=FALSE, echo=FALSE, fig.cap = "Foraging Model: Contour plot of spatial smoother. Purple dots represent acoustically detected encounters. Black dots are all data points with effort included in the model.", fig.width=6, fig.height=4}

png(file = "C:/Users/yvers/OneDrive/PHD/Chapter 3-Sperm SDM/writing/REVISIONS/Foraging_Smoother2Dplot_c.png", width = 9, height = 5, res = 300, units = "in") # 8x6"

par(mfrow = c(1,1),mar=c(4.5,5,2,1))

plot(modForageBest, select = 1, scheme = 2, lwd = 2, cex.axis = 1.2, cex.lab = 1.5, main='',
     contour.col = 'black', hcolors=magma(50)) #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot

#for 2D smoother plot
points(whales$Longitude, whales$Latitude, pch = 16, col='#000DFF', #mediumslateblue
       lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

dev.off()
```

Use for color legend for 2D spatial smoother
```{r}
# vis.gam(modForageBest, view = c("Longitude", "Latitude"), plot.type = "contour", contour.col = "blue", color = "heat")
# library(mgcViz)
# getIt <- getViz(modForageBest)
# getIt2 <- plot(sm(getIt, 1))

png(file = "C:/Users/yvers/OneDrive/Documents/Publications/2022_FiRS_SDMs/figures/Foraging_Smoother2Dlegend.png", width = 9, height = 5, res = 300, units = "in") # 8x6"

plot(sm(getIt, 1)) + l_fitRaster() + l_fitContour() +
  scale_fill_gradientn(colours = magma(50)) +l_points(shape=16, size=0.3, alpha=0.25)

dev.off()
# plot(modForageBest, allTerms = T) #plot all terms



```



Set up plots without Chl-a, modForage4
```{r echo=FALSE, fig.cap = "Foraging Model: Partial effects plots for the spatial contour, Temperature at 584 m and SSHsd." , fig.width=8, fig.height=9}

mlay <- rbind(c(1,1), c(2,3))
# print(mlay)
# layout(mlay)
# layout.show(4)

layout(mlay)
par(mar=c(4,4,1,1))
# par(mar=c(4,4,3,2),mfrow = c(2,2))
# plot(modForageBest)
plot(modForage4, select = 1, scheme = 2, lwd = 2) #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot

#for 2D smoother plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

plot(modForage4, select=2, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='Temp at 584 m (°C)' , seWithMean = TRUE, ylim = c(-2,2))#, shift = coef(modForageBest)[1],	trans	= function(x)	exp(x))

plot(modForage4, select=3, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='SSHsd (m)',seWithMean = TRUE, ylim = c(-2,2) )

mtext(paste0("Foraging Whales"), side=3, line=1, outer=TRUE, cex=1, font=1)

```


Visualize the raw data
```{r echo=FALSE, fig.cap = "Foraging Model: The encounter rate (Groups per cell) plotted separately as a function of Temperature at 584 m, log.Chla, and SSHsd."}

par(mar=c(4,4,1,2),mfrow = c(3,1))

plot(trainHunt$Temp584m, trainHunt$pa, ylab="Groups per cell", xlab="Temp at 584m")
plot(trainHunt$log.Chla, trainHunt$pa, ylab="Groups per cell", xlab="log.Chla")
plot(trainHunt$SSHsd, trainHunt$pa, ylab="Groups per cell", xlab="SSHsd")

```



$~$
#### 2) Non-Foraging Model  

  * gam(pa ~  s(Longitude, Latitude, k=10) + s(Depth, k=3)
  
  * Depth and the spatial smoother were the two variables that best explained the data for the non-foraging groups. The U-shaped relationship of depth predicted the most groups at the deeper and shallower depths. The least groups were predicted for depths between 3000-3500 m. 
  * Non-foraging groups consisted of slow clicks and codas, sometimes both within the same encounter. It's possible that there are different factors driving the distribution of non-foraging whales that were not included in the model. This could be related to reproductive behavior since the non-foraging groups likely include males and social groups of females and jueveniles. 
  * Note: When only the spatial smoother was fitted for the non-foraging model, it performed nearly as well as the model that also included depth. This implies that depth (and the other nonsignificant environmental variables) do not provide much inforation for explaining the distribution of non-foraging groups. 
  
```{r echo=FALSE, eval=FALSE}
### BEST NON-FORAGING MODEL w/ 2D Smoother ####
modNonFor <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Depth, k=3) + s(distland.r, k=3)  + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort), data = trainNonFor, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modNonFor) 

modNonFor2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Depth, k=3) + offset(log.effort) , data = trainNonFor, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modNonFor2) 

modNonFor2 <- modNonForBest
saveRDS(modNonForBest,  here::here( paste0('code/REVISIONS/BEST_NonForagingModel.rda') ))

modNonForBest <-  readRDS(here::here( paste0('code/REVISIONS/BEST_NonForagingModel.rda') ))
```

### Non-Foraging Effects Plots
```{r echo=FALSE, eval=FALSE}


png(file = "C:/Users/yvers/OneDrive/Documents/Publications/2022_FiRS_SDMs/figures/NonForaging_EffectsPlot_b.png", width = 4, height = 4, res = 300, units = "in") 

par(mar=c(4,4,1,3),mfrow = c(1,1))
plot(modNonForBest, select=2, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='Depth (m)' , seWithMean = TRUE, ylim = c(-2,3) )

dev.off()

```
### Non-Foraging 2D plot
```{r}
png(file = "C:/Users/yvers/OneDrive/Documents/Publications/2022_FiRS_SDMs/figures/NonForaging_EffectsPlot.png", width = 9, height = 5, res = 300, units = "in") # 8x6"

par(mfrow = c(1,1),mar=c(4.5,5,2,1))

plot(modNonForBest, select = 1, scheme = 2, lwd = 2, cex.axis = 1.2, cex.lab = 1.5, main='',
     contour.col = 'black', hcolors=magma(50)) #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainNonFor, pa >0) #get points for whales to plot

#for 2D smoother plot
points(whales$Longitude, whales$Latitude, pch = 16, col='#000DFF', #mediumslateblue
       lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

dev.off()
```

```{r}
#Get the color legend from this plot
getIt_NonFor <- getViz(modNonForBest)
getIt2 <- plot(sm(getIt, 1))

png(file = "C:/Users/yvers/OneDrive/Documents/Publications/2022_FiRS_SDMs/figures/NonForaging_Smoother2Dlegend.png", width = 9, height = 5, res = 300, units = "in") 

plot(sm(getIt_NonFor, 1)) + l_fitRaster() + l_fitContour() +
  scale_fill_gradientn(colours = magma(50)) +l_points(shape=16, size=0.3, alpha=0.25)

dev.off()
```





```{r echo=FALSE, fig.cap = "Non-Foraging Model selected depth and spatial smoother, which was significant despite the straight contour lines. Purple dots represent acoustically detected encounters. Black dots are all data points with effort included in the model.", fig.width=8, fig.height=9}

par(mfrow = c(1,1), mar=c(5,5,3,1))

plot(modNonForBest, select=2, residuals = FALSE, pch = 20, shade = T, scheme = 2, shade.col = 'gray85', all.terms = TRUE, xlab='Depth (m)' , seWithMean = TRUE, cex.axis = 1.2, cex.lab = 1.5 )

plot(modNonForBest, select = 1, scheme = 2, lwd = 2,cex.axis = 1.2, cex.lab = 1.5, main='' ) #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainNonFor, pa >0) #get points for whales to plot

#for 2D smoother plot
points(whales$Longitude, whales$Latitude, pch = 16, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)
```
#Non-forage contour plot
```{r}
getIt <- getViz(modNonForBest)
getIt2 <- plot(sm(getIt, 1))

plot(sm(getIt, 1)) + l_fitRaster() + l_fitContour() +
  scale_fill_gradientn(colours = heat.colors(50))

```

```{r echo=FALSE, fig.cap = "Side-by-side comparison of spatial plots for Foraging and Non-Foraging models. Foraging whales represent groups with regular clicks and creaks. Non-foraging whales represent groups with codas and slow clicks present.", fig.width=8, fig.height=9}
par(mfrow = c(2,1), mar=c(4,4,1,2))
## SIDE BY SIDE ####
#Foragers
plot(modForageBest, select = 1, scheme = 2, lwd = 2, main = 'Foragers') #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

# modForage2Donly <-gam(pa ~  s(Longitude, Latitude, k=10) + offset(log.effort), data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
# plot(modForage2Donly, select = 1, scheme = 2, lwd = 2, main = 'Foragers-spatial smooth only')
# summary(modForage2Donly)

## Non-Foragers
plot(modNonForBest, select = 1, scheme = 2, lwd = 2, main = 'Non-Foragers') #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainNonFor, pa >0) #get points for whales to plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

# modNonForage2Donly <-gam(pa ~  s(Longitude, Latitude, k=10) + offset(log.effort), data = trainNonFor, family = nb, link = 'log', select = TRUE, method = "REML")
# plot(modNonForage2Donly, select = 1, scheme = 2, lwd = 2, main = 'Foragers-spatial smooth only')
# summary(modNonForage2Donly)

```


```{r echo=FALSE}
#PREDICTIONS #####
require(magrittr)
require(dplyr)

## no spatial smoother ##
nbTrainFinal1 <- trainHunt %>% mutate(resid = resid(modForageBest), predict = predict(modForageBest))
predTrain1 <- predict.gam(modForageBest, type = 'response', se.fit=TRUE)  #calculate MSE for these to compare with test set. If they're super different, speaks to the genrality of the model
nbTrainFinal1$fit <- predTrain1$fit
nbTrainFinal1$se.fit <- predTrain1$se.fit
#using scale of 0,1,2 makes this hard to interpret
nbMSEtrain1 <- mean((nbTrainFinal1$pa - nbTrainFinal1$fit)^2)  #MSE


# mean(abs((nbTrainFinal$pa - nbTrainFinal$fit)))  #Mean absolute error
## Calculate MSE AFTER transforming the predictions back to the same scale as the observed data

nbPred1 <- predict.gam(modForageBest, newdata = testHunt, type = 'response', se.fit = TRUE)
nbTestFinal1 <- data.frame(testHunt, fit = nbPred1$fit, se.fit=nbPred1$se.fit)
nbMSEtest1 <- mean((nbTestFinal1$pa - nbTestFinal1$fit)^2) #MSE



### Non-Foraging Model ####
#pulling the prediction and residual data from the model
nbTrainLL1 <- trainNonFor %>% mutate(resid = resid(modNonForBest), predict = predict(modNonForBest))
predTrainLL1 <- predict.gam(modNonForBest, type = 'response')  #calculate MSE for these to compare with test set. If they're super different, speaks to the genrality of the model
nbTrainLL1$fit <- predTrainLL1

#using scale of 0,1,2 makes this hard to interpret
nbMSEtrainLL1 <- mean((nbTrainLL1$pa - nbTrainLL1$fit)^2)  #MSE
# mean(abs((nbTrainFinal$pa - nbTrainFinal$fit)))  #Mean absolute error
## Calculate MSE AFTER transforming the predictions back to the same scale as the observed data

nbPredLL1 <- predict.gam(modNonForBest, newdata = testNonFor, type = 'response', se.fit = TRUE)
nbTestLL1 <- data.frame(testNonFor, fit = nbPredLL1$fit, se.fit=nbPredLL1$se.fit)
nbMSEtestLL1 <- mean((nbTestLL1$pa - nbTestLL1$fit)^2) #MSE

# mean(abs((testFinal$pa - testFinal$fit))) #Mean absolute error

# AIC
AICforage <- AIC(modForageBest)
AICNonForage <- AIC(modNonForBest)

# Explained Deviance
nbExpDev1 = round(((modForageBest$null.deviance-modForageBest$deviance)/modForageBest$null.deviance)*100, 2)
nbExpDevLL1 = round(((modNonForBest$null.deviance-modNonForBest$deviance)/modNonForBest$null.deviance)*100, 2)

# Summary table
# 
table2 = matrix(NA, nrow = 2, ncol = 6)
colnames(table2) = c("Models", "ExpDev", "AIC", "MSEtrain", "MSEtest", "Predictor Variables")

### HARD CODED SOME VALUES BC THEY WERE BEING A LITTLE BITCH
table2[1,] <- c("Foraging", paste0(nbExpDev1, '%'), 677.37, round(0.03002856,3), round(0.02922875,3), 
              paste0('SST, Temp at 584 m, log.Chla, SSHsd, LON:LAT'))
table2[2,] <- c("Non-Foraging", paste0(nbExpDevLL1, '%'), round(AICNonForage,2), round(nbMSEtrainLL1,3),
               round(nbMSEtestLL1,3), paste0('Depth, LON:LAT'))
require(knitr)
# kable(table, caption = "Summary Results for Foraging and Non-Foraging Models")
kable(table2, caption = "Summary Results for Foraging and Non-Foraging Models")
```


$~$



```{r echo=FALSE, fig.cap= 'The higher density areas with more foraging groups are further illustrated with a bimodal distribution of longitudes where the two peaks correspond with the spatial contour plots. The distribution of latitudes are more normally distributed, but there is evidence of peaks between 22-24°N and 26-28°N. Few whales occurred below 20°N.'  }
## Foraging Lat:Lon ####

PmFor = rbind(trainHunt, testHunt)
PmFor2 <- subset(PmFor, pa >0)
saveRDS(PmFor, here::here( paste0('data/Pm_ForagingOnly.rda') ))
# PmFor2$Longitude = ifelse(PmFor2$Longitude > 180, PmFor2$Longitude-360, PmFor2$Longitude)
# lon = ifelse(sw$lon>180, sw$lon-360, sw$lon)
par(mfrow = c(2,2), mar=c(4,4,1,2))

# Foraging
hist(PmFor2$Latitude, breaks = 5, main= '', xlab='Latitude of Foraging Groups')
plot(PmFor$Latitude, PmFor$pa, ylab="Foraging Groups per cell", xlab="Latitude (All Data)")

hist(PmFor2$Longitude, breaks = 10, main = '', xlab='Longitude of Foraging Groups')
plot(PmFor$Longitude, PmFor$pa, ylab="Foraging Groups per cell", xlab="Longitude (All Data)")
```

```{r echo=FALSE, fig.cap= 'Non-foraging groups are distributed evenly across latitudes with more occurring in the western portion of the study area. Few whales occurred below 20°N. '}
par(mfrow = c(2,2), mar=c(4,4,1,2))

## NonForaging Lat:Lon ####
PmNonFor = rbind(trainNonFor, testNonFor)
PmNonFor2 <- subset(PmNonFor, pa >0)
saveRDS(PmNonFor, here::here( paste0('data/Pm_NonForagingOnly.rda') ))

# Non-Foraging
hist(PmNonFor2$Latitude, breaks = 5, main= '', xlab='Latitude of Non-Foraging Groups')
plot(PmNonFor$Latitude, PmNonFor$pa, ylab="Non-Foraging Groups per cell", xlab="Latitude (All Data)")

hist(PmNonFor2$Longitude, breaks = 10, main = '', xlab='Longitude of Non-Foraging Groups')
plot(PmNonFor$Longitude, PmNonFor$pa, ylab="Non-Foraging Groups per cell", xlab="Longitude (All Data)")

```

```{r eval=TRUE, echo=FALSE, fig.cap='Contour plot of temperature at 584 m.' }


modTemp584 <- gam(Temp584m ~  s(Longitude, Latitude, k=100) , data = PmFor, select = TRUE, method = "REML") 
modTemp584 <- gam(Temp584m ~  s(Longitude, Latitude, k=10) , data = PmFor, select = TRUE, method = "REML") 
modTemp584 <- gam(Temp584m ~  s(Longitude, Latitude, k=50) , data = PmFor, select = TRUE, method = "REML") 

summary(modTemp584) 

par(mfrow = c(1,1))

plot(modTemp584, select = 1, scheme = 2, lwd = 2, main = 'Temp at 584m ~ LAT:LON, k=10') #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)

```
```{r echo=FALSE, eval=FALSE}
## FAIL: NO NEED-contour plot Temp584m ####
require(akima)
require(plotly)
library(pracma)

# Looking at temp at depth for Foraging groups

ctour =ggplot(PmFor, aes(Longitude, Latitude, z= Temp584m)) 
ctour +  geom_density_2d_filled()
ctour + geom_density_2d()
ctour +geom_contour()




a = interp(PmFor$Longitude,PmFor$Latitude,PmFor$Temp584m, duplicate = "mean")

plot_ly( x = a$x,
         y = a$y,
         z = matrix(a$z, nrow = length(a$y)),
         type="contour")

plot_ly( z = matrix(PmFor$Temp584m),
         type="contour")

filled.contour(sort(PmFor$Longitude),
               sort(PmFor$Latitude),
               PmFor$Temp584m)

ggplot(PmFor, aes(Longitude, Latitude, z = Temp584m)) +
  geom_contour_filled()

x = rand(15,1)
y = rand(15,1)
z = rand(15,1)

a = interp(x, y, z)

plot_ly(x = a$x,
        y = a$y,
        z = matrix(a$z, nrow = length(a$y), byrow = TRUE),
        type = "contour")
# https://www.r-statistics.com/2016/07/using-2d-contour-plots-within-ggplot2-to-visualize-relationships-between-three-variables/
# 
# data(mtcars)
# data.loess <- loess(qsec ~ wt * hp, data = mtcars)
# # Create a sequence of incrementally increasing (by 0.3 units) values for both wt and hp
# xgrid <-  seq(min(mtcars$wt), max(mtcars$wt), 0.3)
# ygrid <-  seq(min(mtcars$hp), max(mtcars$hp), 0.3)
# # Generate a dataframe with every possible combination of wt and hp
# data.fit <-  expand.grid(wt = xgrid, hp = ygrid)
# # Feed the dataframe into the loess model and receive a matrix output with estimates of
# # acceleration for each combination of wt and hp
# mtrx3d <-  predict(data.loess, newdata = data.fit)
# # Abbreviated display of final matrix
# mtrx3d[1:4, 1:4]

modLoess <- loess(Temp584m ~ Longitude * Latitude, data = PmFor)

xgrid <- seq(min(PmFor$Longitude), max(PmFor$Longitude), 0.01)
ygrid <- seq(min(PmFor$Latitude), max(PmFor$Latitude), 0.01)

data.fit <- expand.grid(Longitude = xgrid, Latitude = ygrid)

mtrx3D <- predict(modLoess, newdata = data.fit)
mtrx3D[1:4, 1:4]

contour(x = xgrid, y = ygrid, z = mtrx3D, xlab = 'Longitude', ylab = 'Latitude')


##ggplot contour map

# Transform data to long form
mtrx.melt <- reshape::melt(mtrx3D, id.vars = c('Longitude', 'Latitude'), measure.vars = 'qsec')
names(mtrx.melt) <- c('Longitude', 'Latitude', 'Temp584m')
# Return data to numeric form
mtrx.melt$Longitude <- as.numeric(str_sub(mtrx.melt$Longitude,
                                          str_locate(mtrx.melt$Longitude, '=')[1,1] + 1))
mtrx.melt$Latitude <- as.numeric(str_sub(mtrx.melt$Latitude,
                                         str_locate(mtrx.melt$Latitude, '=')[1,1] + 1))

head(mtrx.melt)

 ggplot(mtrx.melt, aes(x = Longitude, y = Latitude, z = Temp584m)) +
         stat_contour(geom = 'polygon', aes(fill = ..level..), colour='red') +
         geom_tile(aes(fill = Temp584m)) + # color based on temp values 
         stat_contour(bins = 10, colour='white') +
         xlab('Longitude)') +
         ylab('Latitude') +
         guides(fill = guide_colorbar(title = 'Temp584m (°C)')) +
         theme_bw() 
         scale_fill_discrete(colors = c("#33cc33","#99ff66","#ff6666","#ff0000"))

plot_ly(mtrx.melt, x = ~Longitude, y = ~Latitude, z = ~Temp584m, type = "contour", 
        width = 600, height = 500)
         
         
         
         
         
         

```



```{r echo=FALSE, eval=FALSE}
# ## What is the depth distribution for each type of non-foraging whale group?
#   * Looking more closely at how the different non-foraging groups were distributed across depth, the histograms show that the slow clicks occur most frequently at depths deeper than 4000 m. The groups with codas, and therefore females and juveniles, also occur in the deepest possible depths with only ~1/3 occurring in depths less than 3000 m. It's possible that some of these groups (both slow clicks and codas) may in fact have also been in the process of foraging but not actively foraging at the time of detection.
# 
# Since the non-foraging model only selected depth along with the spatial smoother, this examines the depth distribution for whale groups that included slow clicks (male sperm whales) and codas (males, females, juveniles). These groups were not mutually exclusive. There were more groups with slow clicks than codas overall. 
# 
# The partial effect plot for depth predicted maximum encounter rates at the deepest and shallowest depths with a minimum near 3000-3500 m depth. This corresponds to the depth distributions shown in the histograms for each non-foraging click group. Both groups spanned most depths, but fewer groups occurred near 3000 m in general, corresponding to the model predictions.
```
```{r echo=FALSE, eval=FALSE, fig.height=6, fig.cap='Depth distributions for non-foraging whale groups by click type. The distribution are similar. This is partly due to some overlap between groups, but also shows these groups occur primarily in depths greater than 3500 m.', fig.dim=c(8,6)}
#Check out whos at what depth for the non-foragers
PmNonFor = rbind(trainNonFor, testNonFor)
PmSlow <- dplyr::filter(PmNonFor, nonfor == 1 & grepl('s', click_code))
# nrow(PmSlow)
PmSlow <- PmSlow[, c(1, 54, 2, 4, 34)]

PmCoda <- dplyr::filter(PmNonFor, nonfor == 1 & grepl('cd', click_code))
# nrow(PmCoda)
PmCoda <- PmCoda[, c(1, 54, 2, 4, 34)]

mlay <- rbind(c(1,1), c(2,3))
# print(mlay)
# layout(mlay)
# layout.show(4)

layout(mlay)
par(mar=c(4,4,1,1))
# par(mfrow = c(2,2), mar=c(4,4,1,2))

plot(trainNonFor$Depth, trainNonFor$pa, ylab="Non-Foraging Groups per cell", xlab="Depth")

hist(PmSlow$Depth, breaks = 20, main= 'Slow Clicks', xlab='Depth (m)')
hist(PmCoda$Depth, breaks = 10, main = 'Codas', xlab='Depth (m)')
```


```{r echo=FALSE}
PmFor2 <- subset(PmFor, pa >0)
# par(mfrow= c(2,2))
# hist(PmFor2$temp600_sd.r, main = '')
# plot(PmFor$temp600_sd.r, PmFor$pa, ylab="Foraging Groups per cell", xlab="SD Temp at 584m")
# hist(PmFor2$eke600m.r, main ='')
# plot(PmFor$eke600m.r, PmFor$pa, ylab="Foraging Groups per cell", xlab="EKE at 584m")

modTemp584sd <- gam(temp600_sd.r ~ s(Longitude, Latitude, k=10) , data = PmFor, select = TRUE, method = "REML") 
summary(modTemp584sd)
gam.check(modTemp584sd)

modEKE584 <- gam(eke600m.r ~  s(Longitude, Latitude, k=10) , data = PmFor, select = TRUE, method = "REML") 
summary(modEKE584)
gam.check(modEKE584)

mlay <- rbind(c(2,3),c(1,1))
# print(mlay)
# layout(mlay)
# layout.show(1)

layout(mlay)
par(mar=c(4,4,1,1))

### TempSD 584m Plots####
plot(modTemp584sd, select = 1, scheme = 2, lwd = 2, main = 'Temp at 584mSD ~ LAT:LON, k=10') #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)
hist(PmFor2$temp600_sd.r, main = '', xlab="SD Temp at 584m")
plot(PmFor$temp600_sd.r, PmFor$pa, ylab="Foraging Groups per cell", xlab="SD Temp at 584m")


### EKE 584m Plots####
plot(modEKE584, select = 1, scheme = 2, lwd = 2, main = 'EKE at 584m ~ LAT:LON, k=10') #select the first smoother, select = 1
hawaiiMap <- readRDS(here::here(paste0('data/hawaiiMap.rda')))
hawaiiMap$Longitude2 = ifelse(hawaiiMap$Longitude<1, hawaiiMap$Longitude+360, hawaiiMap$Longitude)
whales <- subset(trainHunt, pa >0) #get points for whales to plot
points(whales$Longitude, whales$Latitude, pch = 10, col='mediumslateblue', lwd=1.25, cex=1)
points(hawaiiMap$Longitude2, hawaiiMap$Latitude, pch=20, cex = 0.5)
hist(PmFor2$eke600m.r, main ='')
plot(PmFor$eke600m.r, PmFor$pa, ylab="Foraging Groups per cell", xlab="EKE at 584m")

```


```{r echo=FALSE}
## Add SD of Temp600 to Foraging Mods####
modSuper <- gam(pa ~  s(Longitude, Latitude, k=10) + s(depth.r, k=3) + s(distland.r, k=3) + s(distseamt.r, k=3) +  s(SST, k=3) + s(log.Chla, k=3) + s(Temp584m, k=3) + s(SSH, k=3) + s(SSHsd, k=3) + s(log.eke, k=3) + s(log.wp, k=3) + offset(log.effort)
                + s(temp600_sd.r, k=3) + s(eke600m.r, k=3), data = trainHunt, family = nb,
                link = 'log', select = TRUE, method = "REML")
summary(modSuper) 

modForage2 <- gam(pa ~  s(Longitude, Latitude, k=10) + s(Temp584m, k=3) + s(log.Chla, k=3) + s(SSHsd, k=3) + s(SST, k=3) +offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML") #remove qtr and that makes sst non-sig
summary(modForage2) 

modSuper3 <- gam(pa ~  s(Longitude, Latitude, k=10) +
                    s(temp600_sd.r, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modSuper3) 

modSuper4 <- gam(pa ~  s(Longitude, Latitude, k=10) +
                    s(eke600m.r, k=3) + offset(log.effort) , data = trainHunt, family = nb, link = 'log', select = TRUE, method = "REML")
summary(modSuper4) 
```

